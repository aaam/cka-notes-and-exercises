# CKA Exam Prep Notes

These are my notes for preparing for the Certified Kubernetes Administrator Certification, I cannot guarantee they're complete.

Requirements:

- A basic understanding of Kubernetes
  - https://www.cncf.io/the-childrens-illustrated-guide-to-kubernetes/
  - https://www.youtube.com/playlist?list=PL2We04F3Y_43dAehLMT5GxJhtk3mJtkl5
- Access to a cloud provider (not a hard requirement but makes accessing a ready to go cluster easy). Google, Azure and Amazon all have credits/free tiers. [Linux Academy](https://linuxacademy.com/) has a great array of sandbox VMs and loud sandboxes you can use but it's expensive (get your boss to pay).
- If you don't have cloud provider access, a workstation with virtualbox and 8GB of ram will likely get you there. The [Vagrantfiles](https://www.vagrantup.com/) (WIP) include in this repo will bring up clusters in various states.
- Time to practice
- Have read the [curriculum](https://github.com/cncf/curriculum/blob/master/CKA_Curriculum_V1.14.1.pdf)
- The [Kubernetes the hard way](https://github.com/kelseyhightower/kubernetes-the-hard-way) walk through is great but I don't recommend doing it until you have been through the curriculum and understand the basics before diving into the Kubernetes ocean.


## 1.0 - Scheduling - 5%

<details>

 > ### Labels
 >
 > Labels are key/value pairs that can be applied to Kubernetes objects for the purposes of identification and scheduling
 >
 > To label a node use:
 >
 >```bash
 > kubetl label node <nodename> label=labelvalue
 >```
 >
 > You can also label a pod the same way:
 >
 >```bash
 > kubectl label pod <podname> label=labelvalue
 >```
 >
 > or label a pod when creating from kubectl:
 >
 >```bash
 > kubectl run nginx image=nginx --labels="tier=web"
 >```
 >
 > To view the labels on a pod or node use the ```--show-labels``` flag eg:
 >
 >```bash
 > kubectl get node --show-labels
 >```
 >
 >
 > ### Using Label Selectors to schedule pods - [Documentation](https://kubernetes.io/docs/concepts/configuration/assign-pod-node/)
 >
 > Label selectors allow the assigning of pods to particular nodes by using labels
 > 
 > 1. Label a node as above:
 >
 >```bash
 > kubectl label node <nodename> label=labelvalue
 >```
 >
 > 2. Add the nodeSelector field to a pod spec that will place it on the required node
 >
 >```yaml
 >apiVersion: v1
 >kind: pod
 >metadata:
 >  name: nginx
 >  labels:
 >    env: test
 >spec:
 >  containers:
 >  - name: nginx
 >    image: nginx
 >    imagePullPolicy: IfNotPresent
 >  nodeSelector:
 >    disktype: ssd
 >```
 >
 > 3. After updating the node selector. Running ```watch kubectl get pod -o wide``` will show them being moved to the node with the selected label
 >
 > ### Daemon Sets - [Documentation](https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/)
 >
 > Daemon sets are pods that run on some or all the nodes in a cluster.
 >
 > Use cases:
 > - Storage
 > - Monitoring
 >
 > ### Creating a Daemon Set
 >
 > A DaemonSet required minimum spec is below:
 >
 >```yaml
 >apiVersion: extensions/v1beta1
 >kind: DaemonSet
 >metadata:
 >  name: nginx
 >spec:
 >  selector:
 >    matchLabels:
 >      run: nginx
 >  template:
 >    metadata:
 >      labels:
 >        run: nginx
 >    spec:
 >      containers:
 >      - name: nginx
 >        image: nginx
 >```
 >
 > A fast way to create a Daemonset manifest is to create a deployment manifest, change the "kind" field to DaemonSet, and remove the replicas and autogenerated strategy, resources and status fields (anything with curly brackets {} ).
 >
 >```bash
 >kubectl run nginx --image=nginx --dry-run -o yaml > daemonset.yaml
 >```
 >
 > ### Taints and Tolerations - [Documentation](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/)
 >
 > Taints and Tolerations allow a node to repel workloads (taints) and allow pods to ignore (toleration) applied taints.
 >
 > By default, master nodes have the taint "node-role.kubernetes.io/master which can be tolerated to create single node clusters or to schedule workloads like DaemonSets on the master node.
 >
 > To apply a taint to a node:
 >```bash
 >kubectl taint nodes <nodename> key:value:NoSchedule
 >```
 >
 > In the example above, the ```key=value``` values can be customised as required and ```NoSchedule``` is the effect that the taint will have. All 3 values will need to be matched by a toleration to enable a pod to be scheduled.
 >
 > Effects:
 >
 >- NoSchedule: No pod can be scheduled onto the node
 >- PreferNoSchedule: The scheduler will 'try' not to schedule a pod but it is not required
 >- NoExecute: Pods without a taint are evicted immediately.
 > - The 'tolerationSeconds' option specifies how long a pod can remain on the node before being evicted.
 >
 > Taints are also applied to nodes automatically based on node problems such as "not-ready", "out-of-disk" and "memory-pressure". These can also be tolerated if it's required to ignore node problems.
 >
 > To toleration a taint, by adding a toleration to a pod spec:
 >
 >```yaml
 >tolerations:
 >- key: "key"
 >  operator: "Equal"
 >  value: "value"
 >  effect: "NoSchedule"
 >```
 >
 > ### Resource Limits - [Documentation](https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/)
 >
 >Requests and limites can be placed on the Memory and CPU of a container. When there are multiple containers in a pod, the pod requsts and limits are the sum of the containers requests and limits.
 >
 >- CPU: The CPU resource is specified in units of cores. 0.1 of a core is equivelent to 100(m)illicores. 1 CPU is 1000m cores and can be written as a fraction or as a number of millicores.
 >- Memory: The Memory resource is mesured in bytes and can be expressed in any of E,P,T,G,M,K or Ei,Pi,Ti,Gi,Mi,Ki. Most common usages will be Gi or Mi as they are easy to understand powers of two eg 128MiB, 256MiB.
 >
 > #### Requests
 >
 > Resource requests are applied when a pod is scheduled. When the scheduler is picking a node for a pod, it will check if there is enough CPU or memory for the pod to be placed. If there is not enough resources on any node that a pod would otherwise be allowed to run on, it won't be  scheduled at all and will sit in a pending state.
 >
 > Requests are what are required to run the pod and are not a maximum.
 >
 > If the scheduler is checking to see if a pod will run on a node and the requested resources don't fit within the current free resource space after all requests are added together for that node, then the pod will not be scheduled on that node.
 >
 > #### Limits
 >
 > Limits are enforced when a pod is running. For CPU limits, if a container exceeds it's limit, the container may be allowed to exceed the limit for a period of time but it won't be killed for excessive CPU usage. The limit is the total CPU time that the container can use per quota period which is 100ms by default.
 >
 >
 > ### Multiple Schedulers and Pod Configuration - [Documentation](https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/)
 >
 > ### Manually Schedule a pod without a scheduler - [Documentation](https://kubernetes.io/docs/tasks/administer-cluster/static-pod/)
 >
 > ### Display Scheduler Events
 >
 > ### Know how to configure the Kubernetes Scheduler - [Documentation](https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/)

</details>

## 8.0 - Core Concepts - 19%

<details>

</details>

## 10.0 - Installation, Configuration and Validation - 12%

### Node Setup

<details>

  > Disable Swap:
  >
  >`sudo swapoff -a`
  >
  > Comment out swap in /etc/fstab
  >
  >`#UUID=68a49c38-5206-4399-8e94-465bd6b3f92c swap           swap    defaults,noatime,discard 0 2`

  >Setup Container Runtime Interface (CRI) - Docker/Containerd [doc](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)
  >
  >1. Install GPG Key
  >
  > ```bash
  > curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
  > ```
  >
  >2. Add Docker Repo
  >
  > ```bash
  > sudo add-apt-repository \
  > "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
  > ```
  >
  >3. Download Docker using apt
  >
  >```bash
  >sudo apt-get update && sudo apt-get install -y docker-ce
  >```
  >
  >4. Provide daemon configuration file [doc](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)
  >
  >```bash
  >sudo nano /etc/docker/daemon.json
  >```
  >
  >```json
  >{
  >  "exec-opts": ["native.cgroupdriver=systemd"],
  >  "log-driver": "json-file",
  >  "log-opts": {
  >    "max-size": "100m"
  >  },
  >  "storage-driver": "overlay2"
  >}
  >```
  >
  >5. Create Systemd service directory
  >```bash
  > sudo mkdir -p /etc/systemd/system/docker.service.d
  >```
  >
  >6. Restart and Enable docker service for startup
  >```bash
  > sudo systemctl daemon-reload
  > sudo systemctl restart docker
  > sudo systemctl enable docker
  >```
  
  > Download Kubernetes Binaries [doc](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/)
  >
  >1. Add the Kubernetes GPG Key
  >```bash
  > curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
  >```
  >
  >2. Add Kubernetes source list
  >
  >```bash
  >sudo nano /etc/apt/sources.list.d/kubernetes.list
  >deb https://apt.kubernetes.io/ kubernetes-xenial main
  >```
  >
  >3. Update Repo and Install kubelet kubectl and kubeadm
  >```bash
  > sudo apt-get update && sudo apt-get install -y kubelet kubectl kubeadm
  >```
  >
  >4. Hold the Kubernetes binaries at their current versions.
  >```bash
  > sudo apt-mark hold kubelet kubectl kubeadm
  >```

  >5. Enable Bash completion for kubectl and configure an alias for kubectl
  >
  >```bash
  >alias k=kubectl
  >source <(kubectl completion bash | sed 's/kubectl/k/g' )
  >```

</details>

### Master ONLY Setup

<details>

  >Initialise the cluster using Kubeadm
  >
  >```bash
  >sudo kubeadm init --pod-network-cidr=10.244.0.0/16
  >```
  >
  >If required (Vagrant) advertise the external IP or bridge IP of the VM.
  >
  >```bash
  >--apiserver-advertise-address=private-ip-address
  >```

  >Apply CNI: [doc](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/)
  >
  >```bash
  >kubectl apply -f https://docs.projectcalico.org/v3.7/manifests/canal.yaml
  >```
  >

</details>

### Join node to cluster

<details>

  >On the Master, create join token and print kubeadm join command
  >```bash
  >kubeadm token create --print-join-command
  >```

</details>